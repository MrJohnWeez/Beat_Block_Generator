# https://docs.microsoft.com/en-us/visualstudio/code-quality/use-roslyn-analyzers?view=vs-2019
# https://docs.microsoft.com/en-us/visualstudio/code-quality/?view=vs-2019
# https://github.com/dotnet/roslyn-analyzers/blob/main/.editorconfig
# Also a mix of many editorconfig files from github
# Part of this file was autogenerated via visual studio 2019


# Remove the line below if you want to inherit .editorconfig settings from higher directories
root = true

# C# files
[*.cs]

#### Core EditorConfig Options ####

# Indentation and spacing
indent_size = 4
indent_style = space
tab_width = 4

# New line preferences
end_of_line = crlf
insert_final_newline = true

# Default severity
dotnet_analyzer_diagnostic.severity = warning
# Default severity for all IDE code style rules with category 'Style'
dotnet_analyzer_diagnostic.category-Style.severity = warning
# Default severity for all IDE code quality rules with category 'CodeQuality'
dotnet_analyzer_diagnostic.category-CodeQuality.severity = warning

#### .NET Coding Conventions ####

# Organize usings
dotnet_separate_import_directive_groups = false
dotnet_sort_system_directives_first = true
file_header_template = unset

# this. and Me. preferences
dotnet_style_qualification_for_event = false:warning
dotnet_style_qualification_for_field = false:warning
dotnet_style_qualification_for_method = false:warning
dotnet_style_qualification_for_property = false:warning

# Language keywords vs BCL types preferences
dotnet_style_predefined_type_for_locals_parameters_members = true:warning
dotnet_style_predefined_type_for_member_access = true:warning

# Parentheses preferences
dotnet_style_parentheses_in_arithmetic_binary_operators = never_if_unnecessary:none
dotnet_style_parentheses_in_other_binary_operators = never_if_unnecessary:none
dotnet_style_parentheses_in_other_operators = never_if_unnecessary:none
dotnet_style_parentheses_in_relational_binary_operators = never_if_unnecessary:none

# Modifier preferences
dotnet_style_require_accessibility_modifiers = for_non_interface_members:warning

# Expression-level preferences
dotnet_style_coalesce_expression = true:suggestion
dotnet_style_collection_initializer = true:none
dotnet_style_explicit_tuple_names = true:suggestion
dotnet_style_null_propagation = true:suggestion
dotnet_style_object_initializer = true:suggestion
dotnet_style_prefer_auto_properties = true:none
dotnet_style_prefer_compound_assignment = true:suggestion
dotnet_style_prefer_conditional_expression_over_assignment = true:suggestion
dotnet_style_prefer_conditional_expression_over_return = true:none
dotnet_style_prefer_inferred_anonymous_type_member_names = true:suggestion
dotnet_style_prefer_inferred_tuple_names = true:suggestion
dotnet_style_prefer_is_null_check_over_reference_equality_method = true:suggestion
dotnet_style_prefer_simplified_boolean_expressions = true:suggestion
dotnet_style_prefer_simplified_interpolation = true:suggestion

# Field preferences
dotnet_style_readonly_field = true:none

# Parameter preferences
dotnet_code_quality_unused_parameters = non_public:suggestion

#### C# Coding Conventions ####

# var preferences
csharp_style_var_elsewhere = true:none
csharp_style_var_for_built_in_types = false:none
csharp_style_var_when_type_is_apparent = true:none

# Expression-bodied members
csharp_style_expression_bodied_accessors = true:none
csharp_style_expression_bodied_constructors = false:none
csharp_style_expression_bodied_indexers = true:none
csharp_style_expression_bodied_lambdas = true:none
csharp_style_expression_bodied_local_functions = false:none
csharp_style_expression_bodied_methods = when_on_single_line:none
csharp_style_expression_bodied_operators = false:none
csharp_style_expression_bodied_properties = true:none

# Pattern matching preferences
csharp_style_pattern_matching_over_as_with_null_check = true:suggestion
csharp_style_pattern_matching_over_is_with_cast_check = true:suggestion
csharp_style_prefer_switch_expression = true:silent

# Null-checking preferences
csharp_style_conditional_delegate_call = true:suggestion

# Modifier preferences
csharp_prefer_static_local_function = true:suggestion
csharp_preferred_modifier_order = public,protected,private,internal,static,extern,new,virtual,abstract,sealed,override,readonly,unsafe,volatile,async:warning

# Code-block preferences
csharp_prefer_braces = true:warning
csharp_prefer_simple_using_statement = true:silent

# Expression-level preferences
csharp_prefer_simple_default_expression = true:suggestion
csharp_style_deconstructed_variable_declaration = true:suggestion
csharp_style_inlined_variable_declaration = true:suggestion
csharp_style_pattern_local_over_anonymous_function = false:suggestion
csharp_style_prefer_index_operator = true:suggestion
csharp_style_prefer_range_operator = true:suggestion
csharp_style_throw_expression = false:none
csharp_style_unused_value_assignment_preference = discard_variable:suggestion
csharp_style_unused_value_expression_statement_preference = discard_variable:silent
csharp_style_prefer_not_pattern = false:suggestion # IDE0083: Use pattern matching

# 'using' directive preferences
csharp_using_directive_placement = outside_namespace:warning

#### C# Formatting Rules ####

# New line preferences
csharp_new_line_before_catch = true
csharp_new_line_before_else = true
csharp_new_line_before_finally = true
csharp_new_line_before_members_in_anonymous_types = true
csharp_new_line_before_members_in_object_initializers = true
csharp_new_line_before_open_brace = all
csharp_new_line_between_query_expression_clauses = true

# Indentation preferences
csharp_indent_block_contents = true
csharp_indent_braces = false
csharp_indent_case_contents = true
csharp_indent_case_contents_when_block = true
csharp_indent_labels = one_less_than_current
csharp_indent_switch_labels = true

# Space preferences
csharp_space_after_cast = false
csharp_space_after_colon_in_inheritance_clause = true
csharp_space_after_comma = true
csharp_space_after_dot = false
csharp_space_after_keywords_in_control_flow_statements = true
csharp_space_after_semicolon_in_for_statement = true
csharp_space_around_binary_operators = before_and_after
csharp_space_around_declaration_statements = false
csharp_space_before_colon_in_inheritance_clause = true
csharp_space_before_comma = false
csharp_space_before_dot = false
csharp_space_before_open_square_brackets = false
csharp_space_before_semicolon_in_for_statement = false
csharp_space_between_empty_square_brackets = false
csharp_space_between_method_call_empty_parameter_list_parentheses = false
csharp_space_between_method_call_name_and_opening_parenthesis = false
csharp_space_between_method_call_parameter_list_parentheses = false
csharp_space_between_method_declaration_empty_parameter_list_parentheses = false
csharp_space_between_method_declaration_name_and_open_parenthesis = false
csharp_space_between_method_declaration_parameter_list_parentheses = false
csharp_space_between_parentheses = false
csharp_space_between_square_brackets = false

# Wrapping preferences
csharp_preserve_single_line_blocks = true
csharp_preserve_single_line_statements = true

#### Naming styles ####

# Naming rules
# https://github.com/adambarclay/mundane/blob/main/.editorconfig
dotnet_naming_rule.parameters_and_locals_should_be_camel_case.severity = warning
dotnet_naming_rule.parameters_and_locals_should_be_camel_case.symbols = parameters_and_locals
dotnet_naming_rule.parameters_and_locals_should_be_camel_case.style = camel_case

dotnet_naming_rule.interface_should_be_begins_with_i.severity = warning
dotnet_naming_rule.interface_should_be_begins_with_i.symbols = interface
dotnet_naming_rule.interface_should_be_begins_with_i.style = begins_with_i

dotnet_naming_rule.types_should_be_pascal_case.severity = warning
dotnet_naming_rule.types_should_be_pascal_case.symbols = types
dotnet_naming_rule.types_should_be_pascal_case.style = pascal_case

# https://github.com/ShiftLeftSecurity/SharpSyntaxRewriter/blob/master/.editorconfig
dotnet_naming_rule.non_field_members_should_be_pascal_case.severity = warning
dotnet_naming_rule.non_field_members_should_be_pascal_case.symbols = non_field_members
dotnet_naming_rule.non_field_members_should_be_pascal_case.style = pascal_case

# https://github.com/DotNetAnalyzers/DocumentationAnalyzers/blob/master/.editorconfig
dotnet_naming_rule.constants_should_be_pascal_case.severity = warning
dotnet_naming_rule.constants_should_be_pascal_case.symbols = constants
dotnet_naming_rule.constants_should_be_pascal_case.style = upper_snake_case


# Symbols
dotnet_naming_symbols.interface.applicable_kinds = interface
dotnet_naming_symbols.interface.applicable_accessibilities = *
dotnet_naming_symbols.interface.required_modifiers =

dotnet_naming_symbols.types.applicable_kinds = class, struct, interface, enum, delegate, type_parameter, namespace
dotnet_naming_symbols.types.applicable_accessibilities = *
dotnet_naming_symbols.types.required_modifiers =

dotnet_naming_symbols.non_field_members.applicable_kinds = property, event, method
dotnet_naming_symbols.non_field_members.applicable_accessibilities = *
dotnet_naming_symbols.non_field_members.required_modifiers =

# https://stackoverflow.com/questions/49308579/use-different-prefix-for-const-and-non-const-private-members-in-editorconfig
dotnet_naming_symbols.private_fields.applicable_kinds = field
dotnet_naming_symbols.private_fields.applicable_accessibilities = private
dotnet_naming_symbols.private_fields.required_modifiers =

# https://resharper-support.jetbrains.com/hc/en-us/community/posts/360009781359-Resharper-cleanup-code-Bad-value-CanUseEither-loaded-from-setting-ForBuiltInTypes-
dotnet_naming_symbols.constants.applicable_kinds = field, local
dotnet_naming_symbols.constants.applicable_accessibilities = *
dotnet_naming_symbols.constants.required_modifiers = const

# https://github.com/nunit/nunit/blob/master/.editorconfig
dotnet_naming_symbols.parameters_and_locals.applicable_kinds = parameter, local
dotnet_naming_symbols.parameters_and_locals.applicable_accessibilities = *
dotnet_naming_symbols.parameters_and_locals.required_modifiers =

# Naming types
dotnet_naming_style.pascal_case.required_prefix =
dotnet_naming_style.pascal_case.required_suffix =
dotnet_naming_style.pascal_case.word_separator =
dotnet_naming_style.pascal_case.capitalization = pascal_case

dotnet_naming_style.begins_with_i.required_prefix = I
dotnet_naming_style.begins_with_i.required_suffix =
dotnet_naming_style.begins_with_i.word_separator =
dotnet_naming_style.begins_with_i.capitalization = pascal_case

dotnet_naming_style.camel_case.required_prefix =
dotnet_naming_style.camel_case.required_suffix =
dotnet_naming_style.camel_case.word_separator =
dotnet_naming_style.camel_case.capitalization = camel_case

dotnet_naming_style.upper_snake_case.required_prefix =
dotnet_naming_style.upper_snake_case.required_suffix =
dotnet_naming_style.upper_snake_case.word_separator = _
dotnet_naming_style.upper_snake_case.capitalization = all_upper

# https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/style-rules/ide0090
csharp_style_implicit_object_creation_when_type_is_apparent = false

# Analyzers for Unity https://github.com/microsoft/Microsoft.Unity.Analyzers
dotnet_diagnostic.UNT0001.severity = warning # Empty Unity message Performance
dotnet_diagnostic.UNT0002.severity = warning # Inefficient tag comparison	Performance
dotnet_diagnostic.UNT0003.severity = warning # Usage of non generic GetComponent	Type Safety
dotnet_diagnostic.UNT0004.severity = warning # Time.fixedDeltaTime used with Update	Correctness
dotnet_diagnostic.UNT0005.severity = warning # Time.deltaTime used with FixedUpdate [retired]	Correctness
dotnet_diagnostic.UNT0006.severity = warning # Incorrect message signature	Type Safety
dotnet_diagnostic.UNT0007.severity = warning # Null coalescing on Unity objects	Correctness
dotnet_diagnostic.UNT0008.severity = warning # Null propagation on Unity objects	Correctness
dotnet_diagnostic.UNT0009.severity = warning # Missing static constructor with InitializeOnLoad	Correctness
dotnet_diagnostic.UNT0010.severity = warning # Component instance creation	Type Safety
dotnet_diagnostic.UNT0011.severity = warning # ScriptableObject instance creation	Type Safety
dotnet_diagnostic.UNT0012.severity = warning # Unused coroutine return value	Correctness
dotnet_diagnostic.UNT0013.severity = warning # Invalid or redundant SerializeField attribute	Correctness
dotnet_diagnostic.UNT0014.severity = warning # GetComponent called with non-Component or non-Interface type	Type Safety
dotnet_diagnostic.UNT0015.severity = warning # Incorrect method signature with InitializeOnLoadMethod or RuntimeInitializeOnLoadMethod attribute	Type Safety
dotnet_diagnostic.UNT0016.severity = warning # Unsafe way to get the method name	Type Safety
dotnet_diagnostic.UNT0017.severity = warning # SetPixels invocation is slow	Performance
dotnet_diagnostic.UNT0018.severity = warning # System.Reflection features in performance critical messages	Performance
dotnet_diagnostic.UNT0019.severity = warning # Unnecessary indirection call for GameObject.gameObject	Performance
dotnet_diagnostic.UNT0020.severity = warning # MenuItem attribute used on non-static method	Correctness
dotnet_diagnostic.UNT0021.severity = warning # Unity message should be protected [opt-in]	Correctness
dotnet_diagnostic.UNT0022.severity = warning # Inefficient method to set position and rotation	Performance
dotnet_diagnostic.UNT0023.severity = warning # Coalescing assignment on Unity objects	Correctness
dotnet_diagnostic.UNT0024.severity = warning # Give priority to scalar calculations over vector calculations	Performance
dotnet_diagnostic.UNT0025.severity = warning # Input.GetKey overloads with KeyCode argument	Correctness

### Code Style Analyzers
# https://github.cdnweb.icu/dotnet/linker/blob/main/.editorconfig
dotnet_diagnostic.IDE0004.severity = none # IDE0004: Remove unnecessary cast
dotnet_diagnostic.IDE0005.severity = warning # IDE0005: Remove unnecessary usings/imports
dotnet_diagnostic.IDE0029.severity = warning # IDE0029: Null check can be simplified
dotnet_diagnostic.IDE0031.severity = warning # IDE0031: Null check can be simplified
dotnet_diagnostic.IDE0035.severity = warning # IDE0035: Remove unreachable code
dotnet_diagnostic.IDE0041.severity = warning # IDE0041: Null check can be simplified
dotnet_diagnostic.IDE0043.severity = warning # IDE0043: Format string contains invalid placeholder
dotnet_diagnostic.IDE0044.severity = none # IDE0044: Make field readonly
dotnet_diagnostic.IDE0047.severity = warning # IDE0047: Parentheses can be removed
dotnet_diagnostic.IDE0051.severity = none # IDE0051: Remove unused private members (no reads or writes)
dotnet_diagnostic.IDE0052.severity = warning # IDE0052: Remove unread private member
dotnet_diagnostic.IDE0053.severity = warning # IDE0053: Prefer expression bodies for lambdas
dotnet_diagnostic.IDE0054.severity = none # IDE0054: Use compound assignment
dotnet_diagnostic.IDE0055.severity = none # Retrun on same line
dotnet_diagnostic.IDE0058.severity = none # Remove unnecessary expression value
dotnet_diagnostic.IDE0059.severity = warning # IDE0059: Unnecessary assignment to a value
dotnet_diagnostic.IDE0060.severity = warning # IDE0060: Remove unused parameter
dotnet_diagnostic.IDE0063.severity = none # 'using' statement can be simplified
dotnet_diagnostic.IDE0065.severity = warning # IDE0065: Using directives to be placed outside the namespace
dotnet_diagnostic.IDE0066.severity = none # Use switch expression
dotnet_diagnostic.IDE0074.severity = none # IDE0074: Use compound assignment
dotnet_diagnostic.IDE0078.severity = none # Use pattern matching
dotnet_diagnostic.IDE0082.severity = warning # IDE0082: Convert typeof to nameof
dotnet_diagnostic.IDE0110.severity = none # Remove unnecessary discard
dotnet_diagnostic.CA1816.severity = none # call GC.SuppressFinalize(object)



# Microsoft Analyzers that fail and need to be sorted thru
# https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/design-warnings
dotnet_diagnostic.CA1000.severity = none # Do not declare static members on generic types	When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.
dotnet_diagnostic.CA1001.severity = none # Types that own disposable fields should be disposable	A class declares and implements an instance field that is a System.IDisposable type and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.
dotnet_diagnostic.CA1002.severity = none # Do not expose generic lists	System.Collections.Generic.List<(Of <(T>)>) is a generic collection that is designed for performance, not inheritance. Therefore, List does not contain any virtual members. The generic collections that are designed for inheritance should be exposed instead.
dotnet_diagnostic.CA1003.severity = none # Use generic event handler instances	A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets .NET Framework 2.0.
dotnet_diagnostic.CA1005.severity = none # Avoid excessive parameters on generic types	The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents. It is usually obvious with one type parameter, as in List<T>, and in certain cases with two type parameters, as in Dictionary<TKey, TValue>. However, if more than two type parameters exist, the difficulty becomes too great for most users.
dotnet_diagnostic.CA1008.severity = none # Enums should have zero value	The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be "None" to indicate that no values have been set in the enumeration.
dotnet_diagnostic.CA1010.severity = none # Collections should implement generic interface	To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types.
dotnet_diagnostic.CA1012.severity = none # Abstract types should not have constructors	Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.
dotnet_diagnostic.CA1014.severity = none # Mark assemblies with CLSCompliantAttribute	The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute. If this attribute is not present on an assembly, the assembly is not compliant.
dotnet_diagnostic.CA1016.severity = none # Mark assemblies with AssemblyVersionAttribute	.NET uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.
dotnet_diagnostic.CA1017.severity = none # Mark assemblies with ComVisibleAttribute	ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.
dotnet_diagnostic.CA1018.severity = none # Mark attributes with AttributeUsageAttribute	When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code.
dotnet_diagnostic.CA1019.severity = none # Define accessors for attribute arguments	Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.
dotnet_diagnostic.CA1021.severity = none # Avoid out parameters	Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between out and ref parameters is not widely understood.
dotnet_diagnostic.CA1024.severity = none # Use properties where appropriate	A public or protected method has a name that starts with "Get", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.
dotnet_diagnostic.CA1027.severity = none # Mark enums with FlagsAttribute	An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.
dotnet_diagnostic.CA1028.severity = none # Enum storage should be Int32	An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Even though you can change this underlying type, it is not required or recommended for most scenarios.
dotnet_diagnostic.CA1030.severity = none # Use events where appropriate	This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.
dotnet_diagnostic.CA1031.severity = none # Do not catch general exception types	General exceptions should not be caught. Catch a more-specific exception, or rethrow the general exception as the last statement in the catch block.
dotnet_diagnostic.CA1032.severity = none # Implement standard exception constructors	Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.
dotnet_diagnostic.CA1033.severity = none # Interface methods should be callable by child types	An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.
dotnet_diagnostic.CA1034.severity = none # Nested types should not be visible	A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.
dotnet_diagnostic.CA1036.severity = none # Override methods on comparable types	A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than.
dotnet_diagnostic.CA1040.severity = none # Avoid empty interfaces	Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.
dotnet_diagnostic.CA1041.severity = none # Provide ObsoleteAttribute message	A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed, which gives the user information about the obsolete type or member.
dotnet_diagnostic.CA1043.severity = none # Use integral or string argument for indexers	Indexers (that is, indexed properties) should use integral or string types for the index. These types are typically used for indexing data structures and they increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integral or string type cannot be specified at design time.
dotnet_diagnostic.CA1044.severity = none # Properties should not be write only	Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.
dotnet_diagnostic.CA1045.severity = none # Do not pass types by reference	Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Library architects who design for a general audience should not expect users to master working with out or ref parameters.
dotnet_diagnostic.CA1046.severity = none # Do not overload operator equals on reference types	For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object.
dotnet_diagnostic.CA1047.severity = none # Do not declare protected members in sealed types	Types declare protected members so that inheriting types can access or override the member. By definition, sealed types cannot be inherited, which means that protected methods on sealed types cannot be called.
dotnet_diagnostic.CA1050.severity = none # Declare types in namespaces	Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.
dotnet_diagnostic.CA1051.severity = none # Do not declare visible instance fields	The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.
dotnet_diagnostic.CA1052.severity = none # Static holder types should be sealed	A public or protected type contains only static members and is not declared by using the sealed (C#) or NotInheritable (Visual Basic) modifier. A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type.
dotnet_diagnostic.CA1053.severity = none # Static holder types should not have constructors	A public or nested public type declares only static members and has a public or protected default constructor. The constructor is unnecessary because calling static members does not require an instance of the type. The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security.
dotnet_diagnostic.CA1054.severity = none # URI parameters should not be strings	If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.
dotnet_diagnostic.CA1055.severity = none # URI return values should not be strings	This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.
dotnet_diagnostic.CA1056.severity = none # URI properties should not be strings	This rule assumes that the property represents a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.
dotnet_diagnostic.CA1058.severity = none # Types should not extend certain base types	An externally visible type extends certain base types. Use one of the alternatives.
dotnet_diagnostic.CA1060.severity = none # Move P/Invokes to NativeMethods class	Platform Invocation methods, such as those marked with the System.Runtime.InteropServices.DllImportAttribute or methods defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.
dotnet_diagnostic.CA1061.severity = none # Do not hide base class methods	A method in a base type is hidden by an identically named method in a derived type, when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.
dotnet_diagnostic.CA1062.severity = none # Validate arguments of public methods	All reference arguments that are passed to externally visible methods should be checked against null.
dotnet_diagnostic.CA1063.severity = none # Implement IDisposable correctly	All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1064.severity = none # Exceptions should be public	An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from System.Exception, System.SystemException, or System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.
dotnet_diagnostic.CA1065.severity = none # Do not raise exceptions in unexpected locations	A method that is not expected to throw exceptions throws an exception.
dotnet_diagnostic.CA1066.severity = none # Implement IEquatable when overriding Equals	A value type overrides Equals method, but does not implement IEquatable<T>.
dotnet_diagnostic.CA1067.severity = none # Override Equals when implementing IEquatable	A type implements IEquatable<T>, but does not override Equals method.
dotnet_diagnostic.CA1068.severity = none # CancellationToken parameters must come last	A method has a CancellationToken parameter that is not the last parameter.
dotnet_diagnostic.CA1069.severity = none # Enums should not have duplicate values	An enumeration has multiple members which are explicitly assigned the same constant value.
dotnet_diagnostic.CA1070.severity = none # Do not declare event fields as virtual	A field-like event was declared as virtual.

# Disable other folders
# https://issueexplorer.com/issue/OmniSharp/omnisharp-vscode/4718
# https://editorconfig.org/
[/Assets/{Plugins/StandaloneFileBrowser,Plugins/TextMesh Pro,Plugins/UnityWindowsFileDrag-Drop,AssetStore}/**/*.cs]
generated_code = true
dotnet_analyzer_diagnostic.severity = none
